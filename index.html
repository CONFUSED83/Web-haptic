<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Particle Hands Mobile v3</title>
    <style>
        /* Mobile-first Layout */
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; font-family: sans-serif; }
        
        /* Camera Feed: Full Screen Background */
        #video-feed {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            object-fit: cover;
            z-index: 0;
            opacity: 0.2; /* Even more subtle background */
            transform: scaleX(-1); /* Mirror effect */
        }

        /* 3D Layer */
        #canvas-container { 
            position: fixed; top: 0; left: 0; 
            width: 100%; height: 100%; 
            z-index: 1; 
        }

        /* UI Overlay */
        #ui {
            position: absolute; bottom: 30px; left: 0; width: 100%; 
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            z-index: 10; pointer-events: none;
        }
        
        /* Status Badges */
        .status-badge {
            background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255, 255, 255, 0.3);
            color: #00ffcc; padding: 8px 16px; border-radius: 20px;
            font-size: 14px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;
            backdrop-filter: blur(4px);
        }
        
        /* Hand Status Indicator */
        #hand-status {
            width: 10px; height: 10px; border-radius: 50%;
            background-color: #ff3333; /* Red by default (No Hand) */
            display: inline-block; margin-left: 8px;
            transition: background-color 0.2s;
        }

        /* Start Screen Overlay */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; text-align: center;
        }
        
        #start-btn {
            background: linear-gradient(135deg, #00ffcc 0%, #00ccaa 100%);
            border: none; color: #000; padding: 18px 40px;
            font-size: 18px; font-weight: bold; border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0, 255, 204, 0.3);
            margin-top: 20px; cursor: pointer;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <video id="video-feed" playsinline muted autoplay></video>
    <div id="canvas-container"></div>

    <div id="ui">
        <div class="status-badge" id="mode-badge">Initializing...<span id="hand-status"></span></div>
        <div style="font-size: 10px; opacity: 0.7; color: white;">Pinch to Expand â€¢ Tap Cube to Switch</div>
    </div>

    <div id="start-screen">
        <h2>PARTICLE HANDS</h2>
        <p style="opacity: 0.7; max-width: 80%;">Requires Camera Access<br>Hold hand up in good light.</p>
        <button id="start-btn">START EXPERIENCE</button>
    </div>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 1500; 
    const SHAPES = ['sphere', 'flower', 'heart', 'saturn', 'fireworks'];
    let currentShapeIdx = 0;
    
    // --- STATE ---
    let handDetected = false;
    let pinchVal = 1.0;
    let handPos = { x: 0, y: 0 };
    
    // --- THREE.JS SETUP (Same as V2) ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    function adjustCameraDistance() {
        const aspect = window.innerWidth / window.innerHeight;
        camera.position.z = aspect < 1 ? 70 : 50; 
    }
    adjustCameraDistance();

    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Particles/Button setup (Same as V2)
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);

    for(let i=0; i<PARTICLE_COUNT; i++){
        positions[i*3] = (Math.random()-0.5)*100;
        positions[i*3+1] = (Math.random()-0.5)*100;
        positions[i*3+2] = (Math.random()-0.5)*100;
        colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 1.2,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0.9,
        depthWrite: false
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    const btnGeo = new THREE.BoxGeometry(8, 8, 8);
    const btnMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc, wireframe: true });
    const switchBtn = new THREE.Mesh(btnGeo, btnMat);
    switchBtn.position.set(0, -25, 10);
    scene.add(switchBtn);

    // --- SHAPE MATH (Same as V2) ---
    function getShapePoint(type, i) {
        let x, y, z;
        const r = Math.random();
        const t = Math.random() * Math.PI * 2;
        const p = Math.acos((Math.random() * 2) - 1);

        if (type === 'sphere' || type === 'fireworks') {
            const rad = type === 'fireworks' ? 2 : 25;
            x = rad * Math.sin(p) * Math.cos(t);
            y = rad * Math.sin(p) * Math.sin(t);
            z = rad * Math.cos(p);
        } else if (type === 'heart') {
            const scale = 1.8;
            x = 16 * Math.pow(Math.sin(t), 3) * scale * Math.sqrt(r);
            y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * scale * Math.sqrt(r);
            z = (Math.random() - 0.5) * 8;
        } else if (type === 'flower') {
            const k = 5;
            const rad = 30 * Math.sqrt(r) * Math.cos(k * t);
            x = rad * Math.cos(t);
            y = rad * Math.sin(t);
            z = (Math.random() - 0.5) * 10;
        } else if (type === 'saturn') {
            if (i % 4 === 0) {
                x = 12 * Math.sin(p) * Math.cos(t);
                y = 12 * Math.sin(p) * Math.sin(t);
                z = 12 * Math.cos(p);
            } else {
                const dist = 22 + Math.random() * 15;
                x = dist * Math.cos(t);
                y = (Math.random()-0.5)*2;
                z = dist * Math.sin(t);
            }
        }
        return { x, y, z };
    }

    function setShape(name) {
        document.getElementById('mode-badge').innerText = name.toUpperCase();
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const pt = getShapePoint(name, i);
            targetPositions[i*3] = pt.x;
            targetPositions[i*3+1] = pt.y;
            targetPositions[i*3+2] = pt.z;
        }
    }
    setShape(SHAPES[0]);

    // --- MEDIAPIPE HANDS ---
    const videoElement = document.getElementById('video-feed');
    const handStatusIndicator = document.getElementById('hand-status');

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0, 
        // NOTE: Reduced confidence slightly to encourage detection on mobile
        minDetectionConfidence: 0.45, 
        minTrackingConfidence: 0.45
    });

    hands.onResults((results) => {
        // VISUAL FEEDBACK: Change the indicator color
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handDetected = true;
            handStatusIndicator.style.backgroundColor = '#00ffcc'; // Green/Cyan
            
            const lm = results.multiHandLandmarks[0];
            
            // Hand Position/Pinch Logic (Same as V2)
            handPos.x = (1 - lm[8].x) * 2 - 1;
            handPos.y = -(lm[8].y * 2 - 1);

            const dx = lm[4].x - lm[8].x;
            const dy = lm[4].y - lm[8].y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            pinchVal = THREE.MathUtils.mapLinear(dist, 0.03, 0.2, 0.5, 3.0);
            pinchVal = THREE.MathUtils.clamp(pinchVal, 0.5, 4.0);

            // Button Logic (Same as V2)
            const btnScreen = switchBtn.position.clone().project(camera);
            const distToBtn = Math.sqrt(
                Math.pow(handPos.x - btnScreen.x, 2) + 
                Math.pow(handPos.y - btnScreen.y, 2)
            );

            if (distToBtn < 0.2) {
                switchBtn.material.color.setHex(0xff0066);
                if (!switchBtn.userData.pressed) {
                    currentShapeIdx = (currentShapeIdx + 1) % SHAPES.length;
                    setShape(SHAPES[currentShapeIdx]);
                    switchBtn.userData.pressed = true;
                    setTimeout(() => switchBtn.userData.pressed = false, 1000);
                }
            } else {
                switchBtn.material.color.setHex(0x00ffcc);
            }
        } else {
            handDetected = false;
            handStatusIndicator.style.backgroundColor = '#ff3333'; // Red
        }
    });

    // --- ANIMATION (Same as V2) ---
    const clock = new THREE.Clock();
    let time = 0;

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        time += dt;

        // ... Rotation, Button Float, Particle Physics (Code is unchanged from V2) ...
        if(handDetected) {
            particleSystem.rotation.x += (handPos.y * 0.5 - particleSystem.rotation.x) * 0.1;
            particleSystem.rotation.y += (handPos.x * 0.5 - particleSystem.rotation.y) * 0.1;
        } else {
            particleSystem.rotation.y += 0.005;
        }
        
        switchBtn.rotation.x += 0.02;
        switchBtn.rotation.y += 0.02;
        switchBtn.position.y = -25 + Math.sin(time*2)*2;

        const pos = particleSystem.geometry.attributes.position.array;
        const col = particleSystem.geometry.attributes.color.array;
        
        const currentMode = SHAPES[currentShapeIdx];
        const isFireworks = currentMode === 'fireworks';
        let expand = handDetected ? pinchVal : 1.0;
        
        if (isFireworks) expand = (Math.sin(time * 3) + 1.2) * 4;

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const ix = i*3;
            pos[ix] += (targetPositions[ix] * expand - pos[ix]) * 0.08;
            pos[ix+1] += (targetPositions[ix+1] * expand - pos[ix+1]) * 0.08;
            pos[ix+2] += (targetPositions[ix+2] * expand - pos[ix+2]) * 0.08;

            if (handDetected) {
                const hue = (handPos.x + 1) * 0.5 + (i/PARTICLE_COUNT) * 0.2;
                const c = new THREE.Color().setHSL(hue, 0.8, 0.6);
                col[ix] = c.r; col[ix+1] = c.g; col[ix+2] = c.b;
            } else {
                col[ix] = 0.2 + Math.sin(time + i)*0.2; 
                col[ix+1] = 0.8; 
                col[ix+2] = 1.0;
            }
        }

        particleSystem.geometry.attributes.position.needsUpdate = true;
        particleSystem.geometry.attributes.color.needsUpdate = true;

        renderer.render(scene, camera);
    }

    // --- STARTUP - CRITICAL FIX ---
    document.getElementById('start-btn').addEventListener('click', async () => {
        document.getElementById('start-screen').style.display = 'none';
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'user' }
            });
            
            videoElement.srcObject = stream;
            
            // This is the CRITICAL change: Wait for the video to be ready before sending frames.
            await new Promise((resolve) => {
                videoElement.onloadeddata = () => {
                    videoElement.play();
                    resolve();
                };
            });

            // Set up a continuous frame request loop instead of relying solely on CameraUtils
            function sendFrameToHands() {
                if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                     hands.send({image: videoElement});
                }
                requestAnimationFrame(sendFrameToHands);
            }
            sendFrameToHands();
            
            animate();
            document.getElementById('mode-badge').innerText = 'SPHERE';

        } catch (e) {
            alert("Camera Error (V3): " + e.message + "\n\n1. Ensure HTTPS.\n2. Check site permissions for camera access.");
        }
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        adjustCameraDistance();
    });

</script>
</body>
</html>
